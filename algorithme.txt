

probleme difficile :
On parle de probleme difficile quand ils demandent un temps considérable pour etre résolu

Voir les problemes NP complet sur wikipedia




Ce qu'est une heuristique :

Une heuristique est une maniere de trouver une solution
ici dans le cadre du tp, et en theorie des graphes, une heuristique est un algorithme qui
fournit rapidement une solution réalisable (en temps polynomial), pas nécessairement optimale
pour un probleme d'optimisation NP-difficile

On peut avoir plus de précision sur ce site :
https://www.techno-science.net/glossaire-definition/Heuristique.html



On peut proposer un algorithme naïf de ce type :


fonction algorithme_trop_naif(graphe) :
    couleur initialisée à zéro
    pour chaque sommet dans graphe :
        sommet[couleur] = couleur
        couleur++


Cet algorithme est très peu utile, il n'est pas réaliste d'utiliser une nouvelle couleur pour chaque case 
du sudoku par exemple

On proposera un autre algorithme naïf plus intéressant :

fonction glouton_classique(graphe) :
    les_sommets = liste de tous les sommets de graphe
    couleurs_possibles = tableau ordonneé rempli de couleur allant de 1 à nombre de sommet de graphe
    couleur_utilisees = un tableau vide
    pour chaque sommet dans graphe :
        pour chaque voisin dans voisinage de sommet :
            si couleur de voisin est non nulle :
                ajouter à couleur_utilisees la couleur du voisin
        (ordonner couleur_utilisees) 
        couleur de sommet = premiere couleur de couleurs possibles n'étant pas dans couleur utilisée
        vider couleur_utilisees


On ordonne notre tableau (ou liste si besoin) de couleurs_possibles et couleurs_utilisées pour s'assurer
que la couleur attribuée au sommet soit toujours la même pour un même voisinage

je reconnais qu'il n'est pas forcément nécessaire de le préciser en pseudo code, mais c'est vraiment utile de s'en 
rendre compte pour l'implémentation

Un défault de ce glouton est qu'il enregistre autant de couleur que de sommets tout de même, alors qu'elles ne seront pas forcément toutes
utilisée, c'est un usage de mémoire inutile.
Seulement, forcer le tableau couleurs à contenir seulement les couleurs dont on sait à l'avance la nécéssité n'est pas 
un comportement rigoureux car bien qu'on connaisse déja le nombre de couleur d'un sudoku, on pourrait 
tres bien vouloir tester notre glouton_classique sur un tout nouveau jeu, et ne pas connaitre à l'avance le nombre de couleurs 
nécessaires via glouton_classique




On propose un algorithme avancé pour améliorer notre glouton :

fonciton glouton_degre(graphe) :
    les_sommets = liste de tous les sommets de graphe
    couleurs_possibles = tableau ordonneé rempli de couleur allant de 1 à nombre de sommet de graphe
    couleur_utilisees = un tableau vide
    liste_degree = tableau des sommets triés par ordre décroissant des sommets
    pour chaque sommet dans liste degree :
        pour chaque voisin dans voisinage de sommet :
            si couleur de voisin est non nulle :
                ajouter à couleur_utilisees la couleur du voisin
        (ordonner couleur_utilisees) 
        couleur de sommet = premiere couleur de couleurs possibles n'étant pas dans couleur utilisée
        vider couleur_utilisees



Il y a bien sûr d'autres algorithme pour le sudoku, comme celui basé sur les célibataires cachés ou le backtracking


Voilà ma source pour les algorithmes :
https://iut-info.univ-reims.fr/users/coutant/TP3_Coloration.html